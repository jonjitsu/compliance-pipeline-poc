End-to-end use case (step-by-step)

1. Developer commit → GitHub opens a Pull Request.
    -GitHub Actions fires.

2. Build Job: compile, unit & integration tests. If any fail → pipeline stops.
    -Regulatory-Check Job begins:
    -Packages PR diff and metadata.
    -Calls Eliza RAG Agent REST endpoint.

3. Eliza RAG Agent workflow:
    -Embeds diff context if needed.
    -Queries Vector Store for top-k OSFI passages.
    -Feeds passages + diff + prompt into LLM chain.
    -Outputs findings.json (clause, rationale, severity) + SARIF.

4. Severity Ranker evaluates list:
    -If High findings exist → set job to failed; else succeed.

5. PR feedback:
    -Status Check shows ✅/❌.  
    -PR Comment posts bullet list, each with OSFI clause link + “Create JIRA” deep-link.

6. JIRA Cloud auto-creates/updates tickets for every High item, assigns team lead, labels osfi-b13, links to commit SHA.

7. Supply-chain artefacts:
    -SBOM (SPDX) and provenance logs generated by Syft/Trivy.   
    -Evidence Bundle zipped, signed, uploaded to S3; retention 7 years.

8. Branch protection blocks merge until no High tickets remain or waiver label applied.

9. Merge to main triggers second workflow:
    -Re-runs Regulatory-Check for drift.
    -On success → OIDC Deploy to Kubernetes.

10. Runtime Scanner monitors pods; any critical event posts to Eliza API → incident pipeline may open OSFI Technology-Incident report ticket automatically.

11. Compliance Dashboard ingests artefact metadata and JIRA status nightly, giving auditors a real-time view.

12. Policy Ingestion cron detects new OSFI PDF versions, re-embeds, stores hashes, and logs change history; next CI run automatically uses fresh embeddings.

Result: every code change is tied to explicit OSFI control evidence, tickets, and runtime safeguards—meeting B-13, Incident Advisory, E-21, and E-23 expectations.